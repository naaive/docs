# Persistence

## AOF

### 写会策略

| 模式       | 是否阻塞                                 | 特点             |
|:---------|:-------------------------------------|:---------------|
| Always   | 是                                    | 性能差，可靠性好       |
| Everysec | 刷盘由子进程执行，不直接阻塞主进程，但刷盘完成的快慢会影响主线程阻塞时长 | 性能，可靠性tradeoff |
| No       | 是                                    | 性能好,可靠性差       |


### AOF重写

子进程执行AOF重写，好处：

- 子进程进行 AOF 重写期间，主进程可以继续处理命令请求。
- 子进程带有主进程的数据副本，使用子进程而不是线程，可以在避免锁的情况下，保证数据的安全性。

子进程在进行 AOF 重写期间， 主进程还需要继续处理命令， 而新的命令可能对现有的数据进行修改， 这会让当前数据库的数据和重写后的 AOF 文件中的数据不一致。
解决方案：

当子进程在执行 AOF 重写时， 主进程需要执行以下三个工作：
- 处理命令请求。
- 将写命令追加到现有的 AOF 文件中。
- 将写命令追加到 AOF 重写缓存中。

这样一来可以保证：

- 现有的 AOF 功能会继续执行，即使在 AOF 重写期间发生停机，也不会有任何数据丢失。
- 所有对数据库进行修改的命令都会被记录到 AOF 重写缓存中。

当子进程完成 AOF 重写之后， 它会向父进程发送一个完成信号， 父进程在接到完成信号之后， 会调用一个信号处理函数， 并完成以下工作：

- 将 AOF 重写缓存中的内容全部写入到新 AOF 文件中。
- 对新的 AOF 文件进行改名，覆盖原有的 AOF 文件。

**写入缓存**和**改名操作**会造成主进程阻塞， 在其他时候， AOF 后台重写都不会对主进程造成阻塞， 这将 AOF 重写对性能造成的影响降到了最低。



## RDB


内存快照，fork子进程，不阻塞主进程。

**RDB-AOF 混合持久化**：

- RDB 持久化能够快速地储存和恢复数据， 但是在服务器停机时却会丢失大量数据
- AOF 持久化能够有效地提高数据的安全性， 但是在储存和恢复数据方面却要耗费大量的时间

通过
```
aof-use-rdb-preamble yes  # yes：开启，no：关闭
```

当开启混合持久化时，fork出的子进程先将共享的内存副本全量的以RDB方式写入aof文件，然后在将aof_rewrite_buf重写缓冲区的增量命令以AOF方式写入到文件，写入完成后通知主进程更新统计信息，并将新的含有RDB格式和AOF格式的AOF文件替换旧的的AOF文件。  
简单的说：新的AOF文件前半段是RDB格式的全量数据后半段是AOF格式的增量数据
